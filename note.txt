| 符号  | 类型                     |
| --- | ---------------------- |
| `-` | 普通文件                   |
| `d` | 目录                     |
| `l` | 符号链接（link）             |
| `c` | 字符设备（character device） |
| `b` | 块设备（block device）      |
| `s` | 套接字（socket）            |
| `p` | 命名管道（pipe）           |

the modules of vim:

正常模式：在文件中四处移动光标进行修改
插入模式：插入文本
替换模式：替换文本
可视化模式（一般，行，块）：选中文本块
命令模式：用于执行命令

⭐：我们学习不同命令的本质， 是能够更方便的 学习使用更本质的工具进行开发

⭐：学习这些command的同时，内化linux system的设计哲学：
-> everything is file
-> text stream and pipeline
-> small tools
-> permission and ownership
-> hierarchy and filesystem
-> automation


->type man apropos
这几个是用来学习的

stream < > redirection stream
pipeline |   pipeline 只能够走 stdin & stdout, 输出到终端的command不能够用来拼接管道。 
man=Kobe
echo "$man"

Until now, let's make a deep dive to the bash shell gathering

->type(command) 看看是什么类型的command
executable  shell builtin   alias
// type apt   type sudo

->apropos man  看看是某command在manual的第几页

->* . [] "" ''  搜索辅助符

-> & 我先干别的  
-> jobs  (list all the process out)
// 包括jobID and PID
-> ctrl-z暂停 ctrl-c终止
-> fg bg kill   放回前端 放到back
// fg %2  bg %1  kill%3

secure shell 是用来安全地登陆远程服务器的协议。 建立加密的远程终端链接  

-> ssh -p 2222 wang@192.168.1.10   user@remote_ip 
-> ssh-agent  ssh-add  

-> ln -s 软连接（类似快捷方式） ln 硬连接 
两种连接均不额外复制一份源文件 硬指针  软路径  纯复制用cp
-> chmod chmod 775 note.txt    chmod [ugo][+-=][rwx] note.txt

-> chown 更换file的owner & group
-> du    du -hs *   human readable  summary  shelltype 查看磁盘占用情况

-> df  disk free  查看磁盘空间
-> lsblk  listblock  查看设备
-> mount umount 挂载和卸载
-> fdisk mkfs  分区与格式化
-> inode

network网络的部分：
反复内化这 4 张表就够了：
接口状态表（网卡有没有、up/down、IP 是什么）
路由表（包往哪走）
DNS 解析链路（名字 → IP）
路径探测（包是怎么一步步走到目标的）

-> ip link   ip addr  ip route   dig google.com  traceroute google.com

grep 和 正则表达式 regular expression
-> grep -i-o-v

xargs和tee是pipeline 同步工具
-> xargs将stdout的内容一个一个执行某command, 不破坏pipeline  
ls -a | xargs file
-> tee 将stdout的内容重定向到某个file, 但是不破坏pipeline
df -hf | tee diskfree.txt | grep ^a | sort

grep awk sed sort wc uniq cut tr  这些是pipeline常驻命令， 用于manipulate stdout和stdin
->awk  cat logfile | grep ERROR | awk '{ print $1, $5 }'

awk 一种语法
sed editor  | sed 's/and/AND/g' demo.txt
sort
wc   word count  not only count word, but the digit bytes lines...
uniq   operate different & same
cut   just cut
tr   a small editor

--> bash shell通配符号使用  不是正则
{}扩展  echo {a, bb, cc}--{1, 2}! 将所有最小项分别执行  [] 
--> ?代表任意一个字符 *代表任意长度任意字符串  

-> 正则表达式 在shell中需要用‘’单引号括起来 一般来说配合 stream processing tools 使用 exp. grep awk sed vim

⭐：学完这些之后，用shell写脚本，就是把这些tools组合，写到一个.sh文件， 然后bash xx.sh 运行
    比较程式化复杂的脚本就用 C语言写 
    
linux C getopt（） fopen（） fscanf（） fprintf（）等函数

gcc compiler  gdb debugger:
gcc 生成 .out  binary executable file
执行.out 文件
若报错：
1. 程序执行中 → CPU 算术错误 → 发出 SIGFPE 信号
2. 内核收到信号 → 检查 kernel.core_pattern   core_pattern 决定了core怎么生成，放在那里等
3. kernel 暂停程序 → 遍历进程所有内存页
4. 写入 ELF core 文件 → 程序正式退出
5. 终端显示 "(core dumped)"

Core 文件结构：
┌─────────────────┐
│ ELF 头部        │ ← 文件格式 + 段信息
├─────────────────┤
│ 程序头部表      │ ← 描述各内存段位置
├─────────────────┤
│ .text 段        │ ← 代码（只读）
├─────────────────┤
│ .data/.bss 段   │ ← 全局变量
├─────────────────┤
│ 堆（heap）      │ ← malloc 分配
├─────────────────┤
│ 栈（stack）     │ ← 局部变量 + 调用栈
├─────────────────┤
│ 共享库         │ ← printf 等库函数
└─────────────────┘














passward?
