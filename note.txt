| 符号  | 类型                     |
| --- | ---------------------- |
| `-` | 普通文件                   |
| `d` | 目录                     |
| `l` | 符号链接（link）             |
| `c` | 字符设备（character device） |
| `b` | 块设备（block device）      |
| `s` | 套接字（socket）            |
| `p` | 命名管道（pipe）           |

the modules of vim:

正常模式：在文件中四处移动光标进行修改
插入模式：插入文本
替换模式：替换文本
可视化模式（一般，行，块）：选中文本块
命令模式：用于执行命令

⭐：我们学习不同命令的本质， 是能够更方便的 学习使用更本质的工具进行开发

⭐：学习这些command的同时，内化linux system的设计哲学：
-> everything is file
-> text stream and pipeline
-> small tools
-> permission and ownership
-> hierarchy and filesystem
-> automation


->type man apropos
这几个是用来学习的

stream < > redirection stream
pipeline |   pipeline 只能够走 stdin & stdout, 输出到终端的command不能够用来拼接管道。 
man=Kobe
echo "$man"

Until now, let's make a deep dive to the bash shell gathering

->type(command) 看看是什么类型的command
executable  shell builtin   alias
// type apt   type sudo

->apropos man  看看是某command在manual的第几页

->* . [] "" ''  搜索辅助符

-> & 我先干别的  
-> jobs  (list all the process out)
// 包括jobID and PID
-> ctrl-z暂停 ctrl-c终止
-> fg bg kill   放回前端 放到back
// fg %2  bg %1  kill%3

secure shell 是用来安全地登陆远程服务器的协议。 建立加密的远程终端链接  

-> ssh -p 2222 wang@192.168.1.10   user@remote_ip 
-> ssh-agent  ssh-add  

-> ln -s 软连接（类似快捷方式） ln 硬连接 
两种连接均不额外复制一份源文件 硬指针  软路径  纯复制用cp
-> chmod chmod 775 note.txt    chmod [ugo][+-=][rwx] note.txt

-> chown 更换file的owner & group
-> du    du -hs *   human readable  summary  shelltype 查看磁盘占用情况

-> df  disk free  查看磁盘空间
-> lsblk  listblock  查看设备
-> mount umount 挂载和卸载
-> fdisk mkfs  分区与格式化
-> inode

network网络的部分：
反复内化这 4 张表就够了：
接口状态表（网卡有没有、up/down、IP 是什么）
路由表（包往哪走）
DNS 解析链路（名字 → IP）
路径探测（包是怎么一步步走到目标的）

-> ip link   ip addr  ip route   dig google.com  traceroute google.com

grep 和 正则表达式 regular expression
-> grep -i-o-v

xargs和tee是pipeline 同步工具
-> xargs将stdout的内容一个一个执行某command, 不破坏pipeline  
ls -a | xargs file
-> tee 将stdout的内容重定向到某个file, 但是不破坏pipeline
df -hf | tee diskfree.txt | grep ^a | sort

grep awk sed sort wc uniq cut tr  这些是pipeline常驻命令， 用于manipulate stdout和stdin
->awk  cat logfile | grep ERROR | awk '{ print $1, $5 }'

awk 一种语法
sed editor  | sed 's/and/AND/g' demo.txt
sort
wc   word count  not only count word, but the digit bytes lines...
uniq   operate different & same
cut   just cut
tr   a small editor

--> bash shell通配符号使用  不是正则
{}扩展  echo {a, bb, cc}--{1, 2}! 将所有最小项分别执行  [] 
--> ?代表任意一个字符 *代表任意长度任意字符串  

-> 正则表达式 在shell中需要用‘’单引号括起来 一般来说配合 stream processing tools 使用 exp. grep awk sed vim

⭐：学完这些之后，用shell写脚本，就是把这些tools组合，写到一个.sh文件， 然后bash xx.sh 运行
    比较程式化复杂的脚本就用 C语言写 
    
linux C getopt（） fopen（） fscanf（） fprintf（）等函数

gcc compiler  gdb debugger:
gcc 生成 .out  binary executable file
gcc -ggdb -.. test.c -o test.out
执行.out 文件
若报错：
1. 程序执行中 → CPU 算术错误 → 发出 SIGFPE 信号
2. 内核收到信号 → 检查 kernel.core_pattern   core_pattern 决定了core怎么生成，放在那里等
3. kernel 暂停程序 → 遍历进程所有内存页
4. 写入 ELF core 文件 → 程序正式退出
5. 终端显示 "(core dumped)"

Core 文件结构：
┌─────────────────┐
│ ELF 头部        │ ← 文件格式 + 段信息
├─────────────────┤
│ 程序头部表      │ ← 描述各内存段位置
├─────────────────┤
│ .text 段        │ ← 代码（只读）
├─────────────────┤
│ .data/.bss 段   │ ← 全局变量
├─────────────────┤
│ 堆（heap）      │ ← malloc 分配
├─────────────────┤
│ 栈（stack）     │ ← 局部变量 + 调用栈
├─────────────────┤
│ 共享库         │ ← printf 等库函数
└─────────────────┘

->read core file by GDB, find the bug:
gdb ./test.out core ./core.....

common used command in (gdb) mode: f 1  f 2.... list(list the code context of the crash line) p ...(print)


linuxC编译：
gcc  clang  预编译 编译 
编译过程包括： 词法分析 语法分析  语义分析
语义分析好工具： lint

code->proprocesser->string/word analysis-> AST -> Intermediate language->

Intermediate language 类似于伪ISA

-> All things for CPU is to operate REGISTER & RAM    GET to understand this as hardware
-> All things for Code is to operate VARIABLES & OBJECTS

编译器的工作分为前端和后端， 中间桥梁是 Intermediate Representation
             frontend                              backend
           +----------+                        +------------+
      C -> |  Clang   | -+                 +-> |  llvm-x86  | -> x86
           +----------+  |                 |   +------------+
           +----------+  +-> +----------+ -+   +------------+
Fortran -> | llvm-gcc | ---> | llvm-opt | ---> |  llvm-arm  | -> ARM
           +----------+  +-> +----------+ -+   +------------+
           +----------+  |                 |   +------------+
Haskell -> |    GHC   | -+                 +-> | llvm-riscv | -> RISC-V
           +----------+  LLVM IR      LLRM IR  +------------+


编译优化： 编译器可以在从IR->汇编语言 的过程中进行编译优化， 提升程序质量
  可以选择不同编译优化程度

编译器最终生成汇编语言 .s

汇编器将汇编语言->.o  object file 目标文件 unexecutable

链接: .o->.out executable   将.o文件和C runtime 运行时环境打包形成可执行文件.out

编译器和运行时环境是 C语言标准（C11 C99...) 的 主要体现



vim learn:

go through all the lecture exercises 
vim is a model editor 
do different kind of editing
writing lot of code, reading , browse, trivial...   different mode

normal mode + other mode 
mormal mode  navigation 
insert mode  for normal typing texts (i)
replace mode  (R)

modes for selection : visual mode  visual line   visual block  (V, S-V, C-V)

command line mode (:)   
 
command line mode -> some basic command: q wq sp tabnew help 
normal mode -> ^PO   vim's interface is a programming language 
cursor moving : w b e   moving to the next last and the front fo the next word | typically we use b & w, instead of e
cursor moving : 0 $ ^  moving through the line
cursor moving : ^u ^d  moving paging up and down through the buffer
cursor moving : L M H  whole bunch of way of moving

find character: f* F*  t* T*  find and Till some character
complement:  o O

------------------------  previous are a bunch of movement and navigation operation

delete  d+(operate)*   x  
change
undo  u
redo  ^r
copy paste    y yw yy   p

------------------------

visual mode: select 
three visual mode 


tips: *(num) k    numbers of k is pressed

------------------------  

modifier

A I 






























